# Как работают тесты?

## Общие слова
Тесты по сути, написаны, как будто бы вы пишете реальное приложение. У Вас всегда есть часть, которая относится к 
вашему приложению (в данном случае это EchoClient/Server и реализация сокетов) и есть часть занимающаяся интеграционными тестами.


## Что вообще происходит

Ваша задача - заставить сервер и клиент иметь абстракцию канала (как в TCP). То есть клиент, который отправил сообщение,
должен быть уверен, что сервер получил его в том же виде и порядке. На практике - сетевые интерфейсы не предоставляют таких гарантий,
и вы будете встречать различные отклонения от такого поведения. 

В нашем случае мы эмулируем 3 типа отказов - потери пакетов, дупликация пакетов и reordering'и. Из важных типов отказов,
мы здесь по-факту не эмулируем только повышенный latency.

## Инструменты

Для того чтобы эмулировать отказы, мы пользуемся замечательной утилитой [netem](https://man7.org/linux/man-pages/man8/tc-netem.8.html),
которая является частью современного ядра Linux (если быть точнее то это часть tc, он же traffic control, который является частью iproute2, она же утилита ip)

Эта утилита умеет читать все пакеты, идущие через устройство, и fault-inject'ить их. Однако, в нашем случае мы хотим,
чтобы изменялись пакеты только для нашего приложения (не для всей системы сразу). Пакеты, которые не покидают пределов компьютера,
идут через интерфейс lo-loopback. Мы могли бы изменить настройки прохождения через него командой
```bash
tc qdisc add dev lo root netem loss 50%
```
Такая команда будет дропать 50% пакетов, идущих через интерфейс lo.

Но к сожалению (или к счастью), все пакеты в Linux проходят через этот интерфейс, (из-за того чтобы любой пакет, который должен остаться внутри системы, будет оставаться там)
мы не можем просто взять и изменить его, это скажется на всей вашей системе. Здесь есть несколько путей решения проблемы:
- Использовать виртуальные интерфейсы (tun/tap)
- Использовать Linux namespaces.

Виртуальные интерфейсы используются часто для vpn подключений, или же для создания софтверных бриджей/роутеров. Возможно рассмотрим их на этом курсе,
есть несколько неудобств в их использовании - необходимость сделать так, чтобы трафик, который вы отправляете, шел через этот интерфейс.
Это делается системным вызовом setsockopt или же с помощью таблицы роутинга (iptables). Поэтому мы не будем их использовать и постараемся сделать так,
чтобы тестируемое приложение потребовало минимальных изменений.
## Как будем делать

Linux namespaces - это вообще отдельная тема для разговора, но пока в общих чертах обозначим, что это по сути полностью автономные и независимые зоны ресурсов операционной системы.
Туда входят диски, сеть, межпроцессное взаимодействие и реализовано все это средствами ядра Linux. Это главная технология,
благодаря которой Docker работает так хорошо в современном мире. Нам потребуется сетевая часть этого стека.

Сетевой namespace создается командой
```bash
ip netns add NAME
```
Все команды нужно выполнять под root'ом. После этого можем посмотреть, что появилось в этом namespace
```bash
sudo ip netns exec NAME ip link show

1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc netem state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
```
Видим, что появился интерфейс lo, который нам и нужен. Осталось только включить его
```bash
ip netns exec NAME ip link set dev lo up
```
Замечаем закономерность, что команды, которые нужно выполнить под определенным namespace'ом начинаются с 
```
ip netns exec <ИмяНеймспейса>
```
Теперь все команды мы можем выполнять из-под этого неймспейса - к примеру 
```bash
ip netns exec NAME tc qdisc replace dev lo root netem loss 50%
```
все так же будет дропать 50% пакетов, но уже только в нашем неймспейсе. И код мы тоже должны запускать из-под этого неймспейса.
Из минусов - могу отметить необходимость рута для запуска всех этих команд - можно обойти добавив в sudoers нужный файлик.

## Где мы во всем этом балагане?

В файле test.sh уже написаны все команды для создания namespace, и запуска тестов, не забываем sudo:
```bash
sudo ./test.sh
```
### Как дебажить
Никак. На самом деле с дебагом будут проблемы. Netem не умеет в детерминированное исполнение (патч ядра который это исправляет уже смержен, и если у вас ядро 6.6rc2 то можете попробовать это использовать).
Поэтому два разных запуска будут давать два разных исполнения, все как в реальной жизни - привыкайте.

Советы:
- Обложитесь логами максимально, насколько можете (+ старайтесь хранить историю пакетов)
- Можете запустить wireshark в этом namespace'e - теперь вы знаете как
- Напишите юнит тесты с какими-то конкретными сценариями отказов - типа каждый пятый пакет теряется, мы будем за них очень благодарны, и вы точно получите допбаллы

## Ссылки
- [Crush depth или почему нам нужен отдельный namespace](https://blog.io7m.com/2017/08/10/simulating-packet-loss-damage.xhtml)
- [Patch исправляющий рандом](https://github.com/torvalds/linux/commit/3cad70bc74ef8471e30a05a90798904ce8f8feb5)
- [Что такое namespace и cgroup](https://www.nginx.com/blog/what-are-namespaces-cgroups-how-do-they-work/)
- [Формальная верификация TCP](https://www.cl.cam.ac.uk/~pes20/Netsem/paper3.pdf)
- [Как запускать wireshark](https://unix.stackexchange.com/questions/696097/capture-dns-traffic-to-and-from-a-network-namespace-using-tshark)
- 